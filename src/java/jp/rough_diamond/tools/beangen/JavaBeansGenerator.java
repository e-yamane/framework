/* * Copyright (c) 2008, 2009 *  Rough Diamond Co., Ltd.              -- http://www.rough-diamond.co.jp/ *  Information Systems Institute, Ltd.  -- http://www.isken.co.jp/ *  All rights reserved. */package jp.rough_diamond.tools.beangen;import java.io.File;import java.io.FileOutputStream;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.util.LinkedList;import java.util.List;import java.util.Properties;import java.util.Set;import java.util.TreeSet;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import org.apache.velocity.Template;import org.apache.velocity.VelocityContext;import org.apache.velocity.app.Velocity;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;@SuppressWarnings("unchecked")public class JavaBeansGenerator {	private File input;	private File destRoot;	private String encoding;	public JavaBeansGenerator(File input, File destRoot, String encoding) {		this.input = input;		this.destRoot = destRoot;		this.encoding = encoding;	}	public void doIt() throws Exception {        Properties props = new Properties();        props.setProperty("input.encoding",                     "Shift_JIS");        props.setProperty("output.encoding",                    encoding);        props.setProperty("resource.loader",                    "class");        props.setProperty("class.resource.loader.description",  "Velocity File Resource Loader");        props.setProperty("class.resource.loader.class",        "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader");        Velocity.init(props);        DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();        Document doc = db.parse(input);        BeanInfo[] infos = generateBeanInfos(doc.getDocumentElement());        Utility util = new Utility();        for(int i = 0 ; i < infos.length ; i++) {            File dir;            File parentDir;            if(infos[i].packageName.equals("")) {                dir = destRoot;            } else {                dir = new File(destRoot, infos[i].packageName.replace('.', '/'));            }            boolean ret = dir.mkdirs();            if(infos[i].isBaseSeparate()) {            	parentDir = new File(dir, "base");            	ret = parentDir.mkdir();                //FindBugs対応                if(!ret) {                	ret = !ret;                }            } else {            	parentDir = dir;            }            VelocityContext context = new VelocityContext();            context.put("bean", infos[i]);            context.put("util", util);            Template template = Velocity.getTemplate("jp/rough_diamond/tools/beangen/" + "BeansBaseTemplate.vm");            File f = new File(parentDir, "Base" + infos[i].className + ".java");            ret = f.delete();            //FindBugs対応            if(!ret) {            	ret = !ret;            }            FileOutputStream fos = new FileOutputStream(f);            PrintWriter pw = new PrintWriter(new OutputStreamWriter(fos, encoding));            template.merge(context, pw);            pw.flush();            fos.close();            context = new VelocityContext();            context.put("bean", infos[i]);            context.put("util", util);            template = Velocity.getTemplate("jp/rough_diamond/tools/beangen/" + "BeansTemplate.vm");            f = new File(dir, infos[i].className + ".java");            if(!f.exists()) {                fos = new FileOutputStream(f);                pw = new PrintWriter(new OutputStreamWriter(fos, encoding));                template.merge(context, pw);                pw.flush();                fos.close();            }        }	}    public static void main(String[] args) throws Exception {        Properties props = new Properties();        props.setProperty("input.encoding",                     "Shift_JIS");        props.setProperty("output.encoding",                    "Shift_JIS");        props.setProperty("resource.loader",                    "class");        props.setProperty("class.resource.loader.description",  "Velocity File Resource Loader");        props.setProperty("class.resource.loader.class",        "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader");        Velocity.init(props);        String defFileNames = args[0];        File baseDir = new File(args[1]);        System.out.println(defFileNames);        DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();        Document doc = db.parse(new File(defFileNames));        BeanInfo[] infos = generateBeanInfos(doc.getDocumentElement());        Utility util = new Utility();        for(int i = 0 ; i < infos.length ; i++) {            File dir;            File parentDir;            if(infos[i].packageName.equals("")) {                dir = baseDir;            } else {                dir = new File(baseDir, infos[i].packageName.replace('.', '/'));            }            boolean ret = dir.mkdirs();            //FindBugs対応            if(!ret) {            	ret = !ret;            }            if(infos[i].isBaseSeparate()) {            	parentDir = new File(dir, "base");            	ret = parentDir.mkdir();                //FindBugs対応                if(!ret) {                	ret = !ret;                }            } else {            	parentDir = dir;            }            VelocityContext context = new VelocityContext();            context.put("bean", infos[i]);            context.put("util", util);            Template template = Velocity.getTemplate("BeansBaseTemplate.vm");            File f = new File(parentDir, "Base" + infos[i].className + ".java");            ret = f.delete();            //FindBugs対応            if(!ret) {            	ret = !ret;            }            FileOutputStream fos = new FileOutputStream(f);            PrintWriter pw = new PrintWriter(fos);            template.merge(context, pw);            pw.flush();            fos.close();            context = new VelocityContext();            context.put("bean", infos[i]);            context.put("util", util);            template = Velocity.getTemplate("BeansTemplate.vm");            f = new File(dir, infos[i].className + ".java");            if(!f.exists()) {                fos = new FileOutputStream(f);                pw = new PrintWriter(fos);                template.merge(context, pw);                pw.flush();                fos.close();            }        }    }    static BeanInfo[] generateBeanInfos(Element root) throws Exception {        List ret = new LinkedList();        NodeList list = root.getElementsByTagName("bean");        for(int i = 0 ; i < list.getLength() ; i++) {            ret.add(generateBeanInfo((Element)list.item(i)));        }        return (BeanInfo[])ret.toArray(new BeanInfo[ret.size()]);    }    static BeanInfo generateBeanInfo(Element node) throws Exception {        BeanInfo ret = new BeanInfo();        NamedNodeMap map = node.getAttributes();        String fqcn = map.getNamedItem("className").getNodeValue();        System.out.println(fqcn);        int index = fqcn.lastIndexOf('.');        char[] className;        if(index == -1) {            ret.packageName = "";            className = fqcn.toCharArray();        } else {            ret.packageName = fqcn.substring(0, index);            className = fqcn.substring(index + 1).toCharArray();        }        System.out.println(ret.packageName);        className[0] = Character.toUpperCase(className[0]);        ret.className = new String(className);        System.out.println(ret.className);        Node extendClassName = map.getNamedItem("extends");        if(extendClassName != null) {            ret.extendClassName = extendClassName.getNodeValue();        }        ret.extendClassName = (ret.extendClassName == null) ? "" : ret.extendClassName.trim();        System.out.println(ret.extendClassName);        Node attr = map.getNamedItem("description");        if(attr != null) {            ret.description = attr.getNodeValue();        }        ret.description = (ret.description == null) ? "" : ret.description.trim();        System.out.println(ret.description);        ret.props = generateProperties(node.getElementsByTagName("property"), ret);        Node baseSeparate = map.getNamedItem("baseSeparate");        if(baseSeparate == null) {        	ret.setBaseSeparate(true);        } else {        	ret.setBaseSeparate(Boolean.valueOf(baseSeparate.getNodeValue()));        }        return ret;    }    static Property[] generateProperties(NodeList list, BeanInfo bean) throws Exception {        Set ret = new TreeSet();        Set imports = new TreeSet();        for(int i = 0 ; i < list.getLength() ; i++) {            Property prop = new Property();            NamedNodeMap map = list.item(i).getAttributes();            char[] nameArray = map.getNamedItem("name").getNodeValue().toCharArray();            nameArray[0] = Character.toLowerCase(nameArray[0]);            prop.name = new String(nameArray);            System.out.println(prop.name);            String type = map.getNamedItem("type").getNodeValue();            String[] typeArray = separateGenerics(type);            int index = typeArray[0].lastIndexOf('.');            if(index == -1) {                prop.type = typeArray[0];            } else {                prop.type = typeArray[0].substring(index + 1) + typeArray[1];                System.out.println(prop.type);                typeArray[0] = typeArray[0].replaceAll("\\[\\]", "");                System.out.println(typeArray[0]);                imports.add(typeArray[0]);            }            System.out.println(prop.type);            Node attr = map.getNamedItem("description");            if(attr != null) {                prop.description = attr.getNodeValue();            }            prop.description = (prop.description == null) ? "" : prop.description.trim();            System.out.println(prop.description);            attr = map.getNamedItem("transient");            if(attr != null) {                prop.transientBoolean = Boolean.valueOf(attr.getNodeValue());            } else {                prop.transientBoolean = false;            }            ret.add(prop);        }        bean.imports = (String[])imports.toArray(new String[imports.size()]);        return (Property[])ret.toArray(new Property[ret.size()]);    }    private static Pattern p;    static {    	p = Pattern.compile("([^\\<]+)(\\<([^\\>]+)\\>)?");    }    /**     * 以下の２つの情報に分離する     * ・フルクラス名     * ・ジェネリクスタイプ     * @param type     * @return     */    public static String[] separateGenerics(String type) {    	System.out.println(type);    	Matcher m = p.matcher(type);    	if(m.matches()) {    		String[] ret = new String[2];    		ret[0] = m.group(1);    		ret[1] = (m.group(2) == null) ? "" : m.group(2) ;    		return ret;    	} else {    		return new String[]{type, ""};    	}    }        public static class Utility {        public String getGetterName(Property prop) {            char[] array = prop.name.toCharArray();            array[0] = Character.toUpperCase(array[0]);            if(prop.type.equals("boolean")) {                return "is" + new String(array);            } else {                return "get" + new String(array);            }        }        public String getSetterName(Property prop) {            char[] array = prop.name.toCharArray();            array[0] = Character.toUpperCase(array[0]);            return "set" + new String(array);        }    }    public static class BeanInfo {        public String       packageName;        public String       className;        public String       description;        public String[]     imports;        public Property[]   props;        public String       extendClassName;        public boolean     baseSeparate;        public String getPackageName() {            return packageName;        }        public String getClassName() {            return className;        }        public String getDescription() {            return description;        }        public String[] getImports() {            return imports;        }        public Property[] getProperties() {            return props;        }        public String getExtendClassName() {            return extendClassName;        }		public boolean isBaseSeparate() {			return baseSeparate;		}		public void setBaseSeparate(boolean baseSeparate) {			this.baseSeparate = baseSeparate;		}		public String getParentPackage() {			if(isBaseSeparate()) {				String tmp = getPackageName();				if("".equals(tmp)) {					return "base";				} else {					return tmp + ".base";				}			} else {				return getPackageName();			}		}    }    public static class Property implements Comparable {        public String name;        public String description;        public String type;        public boolean transientBoolean;        public String getName() {            return name;        }        public String getDescription() {            return description;        }        public String getType() {            return type;        }        @Override        public boolean equals(Object o) {        	if(o instanceof Property) {        		if(hashCode() - o.hashCode() != 0) {        			return false;        		}        		return name.equals(((Property)o).name);        	} else {        		return false;        	}        }                @Override        public int hashCode() {        	return name.hashCode();        }                public int compareTo(Object o) {            if(o instanceof Property) {                Property p = (Property)o;                return name.compareTo(p.name);            } else {                return hashCode() - o.hashCode();            }        }        public boolean isTransient() {            return transientBoolean;        }    }}